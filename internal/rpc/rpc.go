// Description: This file contains the gRPC server passthrough implementation for the
// {{ .Config.Name }} API defined in api/{{ .Config.Name }}.proto. The concrete implementation
// exists in the server.go file in this same directory.
package rpc

// "github.com/getoutreach/{{ .Config.Name }}/api"
// "github.com/getoutreach/services/pkg/grpcx"

// GRPCDependencies is used to inject dependencies into the GRPCService service
// activity. Great examples of integrations to be placed into here would be a database
// connection or perhaps a redis client that the service activity needs to use.
type GRPCDependencies struct {
}

// GRPCService is the concrete implementation of the serviceActivity interface
// which defines methods to start and stop a service. In this case the service
// being implemented is a gRPC server.
type GRPCService struct {
	cfg  *Config
	deps *GRPCDependencies
}

// NewGRPCService creates a new GRPCService instance.
func NewGRPCService(cfg *Config, deps *GRPCDependencies) *GRPCService {
	return &GRPCService{
		cfg:  cfg,
		deps: deps,
	}
}

// Servers holds all the server implementation instances.
type Servers struct {
	// DefaultServer api.Service
}

/*
// Run starts a gRPC server.
//
//nolint:funlen // Why: This function is long for extensibility reasons since it is generated by stencil.
func (gs *GRPCService) Run(ctx context.Context) error {
	lc := &net.ListenConfig{}
	listAddr := fmt.Sprintf("%s:%d", gs.cfg.ListenHost, gs.cfg.Port)
	lis, err := lc.Listen(ctx, "tcp", listAddr)
	if err != nil {
		log.Error(ctx, "failed to listen", events.NewErrorInfo(err))
		return err
	}
	defer lis.Close()

	var servers = &Servers{}
	// var opts []grpcx.ServerOption
	server, err := NewServer(ctx, gs.cfg)
	if err != nil {
		log.Error(ctx, "failed to create new server", events.NewErrorInfo(err))
		return err
	}
	// servers.DefaultServer = server

	srv, err := gs.StartServers(ctx, servers) //, opts...)
	if err != nil {
		log.Error(ctx, "failed to start server", events.NewErrorInfo(err))
		return err
	}
	defer srv.Stop()

	// Shutdown the server when the context is canceled
	go func() {
		<-ctx.Done()
		srv.GracefulStop()
	}()

	// Note: .Serve() blocks
	log.Info(ctx, "Serving GRPC Service on "+listAddr)
	if err := srv.Serve(lis); err != nil {
		log.Error(ctx, "unexpected grpc Serve error", events.NewErrorInfo(err))
		return err
	}

	return nil
}

// Close closes the gRPC server.
func (gs *GRPCService) Close(ctx context.Context) error {
	return nil
}

// StartServers starts a RPC server with the provided implementation.
func (gs *GRPCService) StartServers(ctx context.Context, servers *Servers, opts ...grpcx.ServerOption) (*grpc.Server, error) {
	opts = append([]grpcx.ServerOption{}, opts...)

	s, err := grpcx.NewServer(ctx, opts...)
	if err != nil {
		return nil, err
	}

	// Register default server, title function won't work well when use underscore, so we make it dash first
	// api.RegisterServer(s, rpcserver{servers.DefaultServer})

	// Register reflection
	reflection.Register(s)

	return s, nil
}

// rpcserver is a shim that converts the generic Service interface
// into the grpc generated interface from the protobuf
type rpcserver struct {
	api.Service
}

// Ping is a simple ping/pong handler.
func (s rpcserver) Ping(ctx context.Context, req *api.PingRequest) (*api.PingResponse, error) {
	message, err := s.Service.Ping(ctx, req.Message)
	if err != nil {
		return nil, err
	}
	return &api.PingResponse{Message: message}, nil
}

// Pong is a simple RPC that returns a message.
func (s rpcserver) Pong(ctx context.Context, req *api.PongRequest) (*api.PongResponse, error) {
	message, err := s.Service.Pong(ctx, req.Message)
	if err != nil {
		return nil, err
	}
	return &api.PongResponse{Message: message}, nil
}
*/
